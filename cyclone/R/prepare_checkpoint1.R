#' prepare_checkpoint1
#' @export
#' @author Ravi K. Patel
#' @description Checks if the data is provided in a correct format and generates checkpoint_1.RData in out_dir
#' @param raw_exp           data frame of raw expression (cell x features), optional if trans_exp is provided.
#' @param trans_exp         data frame of processed (transformed and/or normalized) expression (cell x features), optional if raw_exp is provided. If only raw_exp is provided, the trans_exp is generated by performing arcsinh transformation (default cofactor 5). If trans_exp is provided, the trans_exp is used as it is without any additional transformation/normalization are performed.
#' @param file_metadata     data frame describing individual files/samples, one per row. Must have following columns: \itemize{
#' \item file_name: unique names of file/sample
#' \item donor_id: identifier indicating the donor of the sample (used only for visualization)
#' \item pool_id: CyTOF pool id or batch id (used only for visualization)
#' \item control_sample: TRUE/FALSE indicating whether the file/sample is a batch control, as often used in CyTOF.  (used for visualization & 'exclude_controls' functionality)
#' \item any additional metadata columns will not be used for anything internal to cyclone, but they will be copied to other outputs for easy access.
#' }
#' @param marker_metadata   data frame listing all markers/features, one per row. Must have following columns: \itemize{
#' \item marker_name: marker names, must match the column names of raw_exp and trans_exp
#' \item used_for_UMAP: TRUE/FALSE indicating whether the marker should be used for UMAP dimensionality reduction.
#' \item used_for_clustering: TRUE/FALSE indicating whether the marker should be used for clustering.
#' \item used_for_scaffold: TRUE/FALSE indicating whether the marker should be used for SCAFFoLD map generation.
#' }
#' @param cell_metadata     data frame with row names matching the rows of raw_exp and trans_exp. Must have following columns: \itemize{
#' \item file_name: file/sample name matching one of the file_name values of file_metadata
#' }
#' @param out_dir           path of output directory that will be used as out_dir for running the cyclone pipeline.
#' @param arcsinh_cofactor  cofactor to use during ArcSinh transformation. If trans_exp is provided, this value is ignored.
#' @param subsample Logical. Whether to downsample by retaining up to \code{subsample_n} number of randomly selected cells per sample
#' @param subsample_n Positive Integer. The maximum number of cells to retain per sample when \code{subsample = TRUE}
#' @param subsample_seed Integer or NULL. For reproducibility purposes, when not NULL, this value is presented to a call to set.seed() prior to performing the random subsampling.
#' @param exclude_controls Logical. Whether to remove samples from the dataset that are marked as controls in \code{file_metadata}
#' @return None directly. Outputs are written to a file, "checkpoint_1.RData" in \code{out_dir}.

prepare_checkpoint1 <- function(
  raw_exp=NULL,
  trans_exp=NULL,
  file_metadata,
  marker_metadata,
  cell_metadata,
  out_dir,
  arcsinh_cofactor=5,
  subsample = FALSE,
  subsample_n = 4000,
  subsample_seed = 123,
  exclude_controls = FALSE
) {
  # Check that raw_exp and trans_exp (if provided) are numeric
  if(!is.null(raw_exp) && !all(sapply(raw_exp, is.numeric)) ) {
    stop("At least on column of raw_exp is non-numeric. Make sure all columns are numeric.")
  }
  if(!is.null(trans_exp) && !all(sapply(trans_exp, is.numeric)) ) {
    stop("At least on column of trans_exp is non-numeric. Make sure all columns are numeric.")
  }
  # Check at least one of raw_exp and trans_exp is provided.
  if(is.null(trans_exp)){
    if(is.null(raw_exp)) {
      stop("At least one of raw expression matrix (raw_exp) and arcsinh-transformed expression matrix (trans_exp) is required. If using non-cytof data, perform appropriate normalization/transformation and supply the data as trans_exp.")
    } else {
      cat("trans_exp is missing, but raw_exp is found. Performing ArcSinh transformation using the provided cofactor.\n")
      trans_exp <- asinh( raw_exp / arcsinh_cofactor )
    }
  }

  # Make sure file_metadata has all required columns
  fileMeta_cols <- c("file_name", "donor_id", "pool_id", "control_sample")
  if( ! all( fileMeta_cols %in% colnames(file_metadata) ) ) {
    stop("At least one required column is missing. All of the following columns are required in file_metadata. ", paste(fileMeta_cols, collapse = ", "))
  }

  # Make sure marker_metadata has all required columns
  markerMeta_cols <- c("marker_name", "used_for_UMAP", "used_for_clustering")
  if( ! all( markerMeta_cols %in% colnames(marker_metadata) ) ) {
    stop("At least one required column is missing. All of the following columns are required in marker_metadata. ", paste(markerMeta_cols, collapse = ", "), "\nused_for_scaffold is also required if running SCAFFoLD.")
  }

  # Make sure cell_metadata has all required columns
  cellMeta_cols <- c("file_name")
  if( ! all( cellMeta_cols %in% colnames(cell_metadata) ) ) {
    stop("At least one required column is missing. All of the following columns are required in cell_metadata. ", paste(cellMeta_cols, collapse = ", "))
  }


  # Check the row names of cell_metadata and trans_exp match
  if(!all(rownames(cell_metadata) == rownames(trans_exp))) {
    stop("Rownames of cell_metadata, raw_exp and trans_exp must match.")
  }

  # Check and print the number of matching marker names in marker_metadata and column names of trans_exp.
  if(sum(marker_metadata$marker_name %in% colnames(trans_exp)) > 0) {
    overlap_markers <- marker_metadata$marker_name[ marker_metadata$marker_name %in% colnames(trans_exp) ]
    cat("Following", length(overlap_markers), "markers overlap between expression data and marker_metadata\n")
    cat(paste0(overlap_markers, collapse = ", "), "\n")
  } else {
    stop("No marker_name from marker_metadata match column names of the expression matrix")
  }

  # Make sure none of the columns used for UMAP and clustering have NA values.
  used_marker_names <- marker_metadata$marker_name[
    marker_metadata$used_for_UMAP | marker_metadata$used_for_clustering
  ]
  na_counts <- sapply(
    trans_exp[, used_marker_names ],
    function(x){sum(is.na(x))}
  )
  if(any(na_counts > 0)) {
    stop("NA values are not allowed in expression matrix. Following columns have NA values.\n", paste( names(which(na_counts > 0)), collapse = ", ") )
  }

  # Add all file metadata to cell_metadata based on matching file_name.
  cellMeta_cols <- colnames(cell_metadata)
  cols_to_add <- colnames(file_metadata)[ ! colnames(file_metadata) %in% c(cellMeta_cols) ]
  if( length(cols_to_add) > 0 ) {
    cell_metadata <- cbind( cell_metadata,
                            file_metadata[ match(cell_metadata$file_name, file_metadata$file_name), cols_to_add, drop=F ]
    )
  }

  # Handle cell/sample-use parameters
  if (exclude_controls || subsample) {
    # Handle control exclusion
    if (exclude_controls) {
      file_metadata <- file_metadata %>% filter( ! control_sample )
      cell_metadata <- cell_metadata %>% filter( ! control_sample )
    }
    # Subsampling if subsample == TRUE
    if (subsample) {
      if (!is.null(subsample_seed)) {
          set.seed(subsample_seed)
      }
      cells_use <- unlist(lapply(
        file_metadata$file_name,
        function(file) {
          cells_in_sample <- rownames(cell_metadata)[cell_metadata$file_name==file]
          sample(cells_in_sample, min(subsample_n, length(cells_in_sample)), replace = FALSE)
        }
      ))
      cell_metadata <- cell_metadata[rownames(cell_metadata) %in% cells_use,]
    }
    # Trim data matrices
    trans_exp <- trans_exp[rownames(cell_metadata),]
    if (!is.null(raw_exp)) {
      raw_exp <- raw_exp[rownames(cell_metadata),]
    }
  }

  # Generate checkpoint_1.RData in out_dir
  cat("Outputting checkpoint_1.Rdata, targeting", nrow(trans_exp), "cells.\n")
  CHECKPOINT <- 1
  save(CHECKPOINT, raw_exp, trans_exp, cell_metadata, file_metadata, marker_metadata, file=file.path(out_dir,"checkpoint_1.RData"))
}
